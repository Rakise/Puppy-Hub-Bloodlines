-- Boss Farm Module for Bloodlines (Optimized & Integrated)
-- Updated: Custom UI-based Server Hop

local BossFarm = {}
BossFarm.__index = BossFarm

-- ============================================
-- SERVICES & DEPENDENCIES
-- ============================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local dataEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("DataEvent")

-- ============================================
-- SETTINGS
-- ============================================
BossFarm.Settings = {
    Enabled = false,
    SelectedBosses = {},
    ServerHopIfChakraSense = false,
    ServerHopIfNoBoss = false,
    AttackInterval = 0.5,
    HealthCheckInterval = 0.3,
    PlayerDetectionRadius = 100,
    FarmHeightOffset = 15,
    SafeHeightOffset = 30
}

-- ============================================
-- BOSS CONFIGS
-- ============================================
local BOSS_CONFIGS = {
    ["Barbarit The Hallowed"] = {
        farmHeight = 16, safeHeight = 55, positionAbove = true,
        dangerousAnimations = { ["rbxassetid://9954909571"] = true },
        animationResponse = "height", requiresSpawn = false
    },
    ["Wooden Golem"] = {
        farmHeight = 15, positionAbove = true,
        dangerousAnimations = { ["rbxassetid://120758909308511"] = true, ["rbxassetid://116907126244057"] = true },
        animationResponse = "teleport", safePosition = Vector3.new(-2950.580, 321.173, -275.704),
        requiresSpawn = false
    },
    ["Chakra Knight"] = {
        farmHeight = 15, safeHeight = 25, positionAbove = false,
        dangerousAnimations = { ["rbxassetid://10141233349"] = true },
        animationResponse = "height", requiresSpawn = false
    },
    ["Hallowed Chakra Knight"] = {
        farmHeight = 15, safeHeight = 25, positionAbove = false,
        dangerousAnimations = { ["rbxassetid://10141233349"] = true },
        animationResponse = "height", requiresSpawn = false
    },
    ["Tairock"] = {
        farmHeight = 11, safeHeight = 30, positionAbove = false,
        dangerousAnimations = {}, animationResponse = "height", requiresSpawn = false
    },
    ["Hallowed Tairock"] = {
        farmHeight = 11, safeHeight = 30, positionAbove = false,
        dangerousAnimations = {}, animationResponse = "height", requiresSpawn = false
    },
    ["Manda"] = {
        farmHeight = 20, safeHeight = 40, positionAbove = true,
        dangerousAnimations = {}, animationResponse = "height", requiresSpawn = true
    }
}

local bossDatabase = {}
for bossName, _ in pairs(BOSS_CONFIGS) do table.insert(bossDatabase, bossName) end
table.sort(bossDatabase)

local SAFE_SPOT = Vector3.new(-2950.580, 321.173, -275.704)

-- ============================================
-- STATE
-- ============================================
local State = {
    running = false,
    currentBoss = nil,
    connections = {},
    animationStates = {},
    lastBossPosition = nil,
    healthThreshold = 0,
    farmThread = nil,
    teleportMode = false,
    inDanger = false
}

-- ============================================
-- UTILS
-- ============================================
local Utils = {}
function Utils.log(message, level)
    local prefix = "[Boss Farm]"
    if level == "warn" then warn(prefix, message) else print(prefix, message) end
end
function Utils.notify(text, duration)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Bloodlines Farm"; Text = text; Duration = duration or 3;
        })
    end)
end
function Utils.getPlayerData()
    local character = LocalPlayer.Character
    if not character then return nil end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not rootPart or not humanoid then return nil end
    return { character = character, rootPart = rootPart, humanoid = humanoid }
end
function Utils.isValidBoss(boss)
    if not boss or not boss.Parent or not boss:IsA("Model") then return false end
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    return humanoid and rootPart and humanoid.Health > 0
end
function Utils.disconnectAll(connections)
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if conn and typeof(conn) == "RBXScriptConnection" then pcall(function() conn:Disconnect() end) end
        connections[i] = nil
    end
end
function Utils.getInDanger()
    return State.inDanger
end

-- ============================================
-- BOSS DETECTION & ANIMATION
-- ============================================
local Detection = {}
function Detection.findBoss(bossName)
    for _, child in pairs(workspace:GetChildren()) do
        if child.Name == bossName and Utils.isValidBoss(child) then return child end
    end
    return nil
end
function Detection.findAnySelectedBoss()
    for bossName, isSelected in pairs(BossFarm.Settings.SelectedBosses) do
        if isSelected then
            local boss = Detection.findBoss(bossName)
            if boss then return boss end
        end
    end
    return nil
end
function Detection.isPlayerNearby(boss, radius)
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local pRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if pRoot and (pRoot.Position - rootPart.Position).Magnitude <= radius then
                return true, player.Name
            end
        end
    end
    return false
end

local Animation = {}
function Animation.setup(boss, config)
    if not config.dangerousAnimations then return end
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return end
    
    State.animationStates[boss] = { 
        dangerous = false, responseType = config.animationResponse or "height", safePosition = config.safePosition
    }
    
    local conn = animator.AnimationPlayed:Connect(function(track)
        if config.dangerousAnimations[track.Animation.AnimationId] then
            State.animationStates[boss].dangerous = true
            State.inDanger = true
            track.Stopped:Connect(function()
                if State.animationStates[boss] then
                    State.animationStates[boss].dangerous = false
                    State.inDanger = false
                end
            end)
        end
    end)
    table.insert(State.connections, conn)
end
function Animation.isDangerous(boss) return State.animationStates[boss] and State.animationStates[boss].dangerous end
function Animation.getResponseType(boss)
    local s = State.animationStates[boss]
    if s then return s.responseType, s.safePosition end
    return "height", nil
end
function Animation.cleanup(boss) State.animationStates[boss] = nil end

-- ============================================
-- TELEPORT
-- ============================================
local Teleport = {}
function Teleport.toSafeSpot(continuous)
    local playerData = Utils.getPlayerData()
    if not playerData then return nil end
    Utils.log("Moving to safe spot" .. (continuous and " (continuous)" or ""))
    if not continuous then playerData.rootPart.CFrame = CFrame.new(SAFE_SPOT) return nil end
    local conn = RunService.Heartbeat:Connect(function()
        local pData = Utils.getPlayerData()
        if pData and pData.rootPart and pData.rootPart.Parent then
            pData.rootPart.CFrame = CFrame.new(SAFE_SPOT)
        end
    end)
    table.insert(State.connections, conn)
    return conn
end
function Teleport.toBoss(boss, config)
    if not Utils.isValidBoss(boss) then return nil end
    local bossRoot = boss:FindFirstChild("HumanoidRootPart")
    if not bossRoot then return nil end
    State.lastBossPosition = bossRoot.Position
    local conn = RunService.Heartbeat:Connect(function()
        if not State.running then return end
        local pData = Utils.getPlayerData()
        if not pData then return end
        if bossRoot and bossRoot.Parent then State.lastBossPosition = bossRoot.Position end
        
        if Animation.isDangerous(boss) then
            local rType, safePos = Animation.getResponseType(boss)
            if rType == "teleport" and safePos then
                pData.rootPart.CFrame = CFrame.new(safePos)
            else
                local h = config.safeHeight or 30
                local y = config.positionAbove and h or -h
                pData.rootPart.CFrame = CFrame.new(State.lastBossPosition + Vector3.new(0, y, 0), State.lastBossPosition)
            end
        else
            local h = config.farmHeight
            local y = config.positionAbove and h or -h
            pData.rootPart.CFrame = CFrame.new(State.lastBossPosition + Vector3.new(0, y, 0), State.lastBossPosition)
        end
    end)
    table.insert(State.connections, conn)
    return conn
end

-- ============================================
-- SERVER HOP SYSTEM (Updated Custom UI)
-- ============================================
local ServerHop = {}

function ServerHop.execute()
    Utils.log("Initiating server hop...")
    
    if Utils.getInDanger() then
        Utils.log("In combat, waiting...")
        Utils.notify("In combat! Waiting...", 3)
        Teleport.toSafeSpot(false)
        while Utils.getInDanger() do task.wait(0.5) end
        Utils.log("Out of combat, proceeding...")
        task.wait(1)
    end
    
    for attempt = 1, 5 do
        local success = pcall(function()
            local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)
            if not playerGui then return end
            
            local clientGui = playerGui:WaitForChild("ClientGui", 5)
            if not clientGui then return end
            
            local list = ServerHop.findServerList(clientGui)
            if not list then return end
            
            local validServers = ServerHop.getValidServers(list)
            if #validServers == 0 then return end
            
            local randomServer = validServers[math.random(1, #validServers)]
            
            if firesignal then
                firesignal(randomServer.button.MouseButton1Down)
                task.wait(0.05)
                firesignal(randomServer.button.MouseButton1Up)
                task.wait(0.05)
                firesignal(randomServer.button.MouseButton1Click)
            else
                Utils.log("firesignal not supported!")
            end
        end)
        
        task.wait(0.35)
        if attempt < 5 then Utils.notify(string.format("Retry %d/5", attempt + 1), 0.5) end
    end
end

function ServerHop.findServerList(clientGui)
    local mainframe = clientGui:FindFirstChild("Mainframe")
    if mainframe then
        local rest = mainframe:FindFirstChild("Rest")
        if rest then
            local serverList = rest:FindFirstChild("ServerList")
            if serverList then
                local backdrop = serverList:FindFirstChild("BackDrop")
                if backdrop then
                    local list = backdrop:FindFirstChild("List")
                    if list and #list:GetChildren() > 0 then return list end
                end
            end
        end
    end
    local menuScreen = clientGui:FindFirstChild("MenuScreen")
    if menuScreen then
        local serverList = menuScreen:FindFirstChild("ServerList")
        if serverList then
            local backdrop = serverList:FindFirstChild("BackDrop")
            if backdrop then return backdrop:FindFirstChild("List") end
        end
    end
    return nil
end

function ServerHop.getValidServers(list)
    local validServers = {}
    for _, frame in ipairs(list:GetChildren()) do
        if frame:IsA("Frame") and frame.Name == "ServerTemplate" then
            local playersLabel = frame:FindFirstChild("Players")
            local joinButton = frame:FindFirstChild("JoinButton")
            if playersLabel and joinButton and joinButton:IsA("TextButton") then
                local playerCount = tonumber(playersLabel.Text:match("%d+"))
                if playerCount and playerCount >= 10 and playerCount < 20 then
                    table.insert(validServers, { button = joinButton, playerCount = playerCount })
                end
            end
        end
    end
    return validServers
end

-- ============================================
-- COMBAT
-- ============================================
local Combat = {}
function Combat.startAttacking()
    local settings = BossFarm.Settings
    return task.spawn(function()
        while State.running and State.currentBoss do
            task.wait(settings.AttackInterval)
            if State.running and State.currentBoss then
                pcall(function() dataEvent:FireServer("CheckMeleeHit", nil, "NormalAttack", false) end)
            end
        end
    end)
end
function Combat.enableNoclip()
    local conn = RunService.Stepped:Connect(function()
        if not State.running then return end
        local pData = Utils.getPlayerData()
        if not pData then return end
        for _, part in pairs(pData.character:GetDescendants()) do
            if part:IsA('BasePart') then part.CanCollide = false end
        end
    end)
    table.insert(State.connections, conn)
    return conn
end

-- ============================================
-- MAIN LOOP
-- ============================================
local Farm = {}
function Farm.start()
    if State.running then return end
    State.farmThread = task.spawn(function()
        State.running = true
        Utils.notify("Boss auto-farm started!", 3)
        while BossFarm.Settings.Enabled and State.running do
            Farm.cleanup()
            local boss = Detection.findAnySelectedBoss()
            if not boss then
                if BossFarm.Settings.ServerHopIfNoBoss then
                    Utils.notify("No bosses found! Hopping...", 3)
                    task.wait(2)
                    ServerHop.execute()
                    break
                else
                    task.wait(2) continue
                end
            end
            
            local playerNearby, playerName = Detection.isPlayerNearby(boss, BossFarm.Settings.PlayerDetectionRadius)
            if playerNearby then
                Utils.log("Player nearby: " .. playerName)
                task.wait(5) continue
            end
            
            Farm.farmBoss(boss)
            task.wait(0.5)
        end
        State.running = false
    end)
end

function Farm.stop()
    BossFarm.Settings.Enabled = false
    State.running = false
    State.currentBoss = nil
    Farm.cleanup()
    if State.farmThread then task.cancel(State.farmThread) end
    Utils.notify("Auto-farm stopped", 2)
end

function Farm.cleanup()
    Utils.disconnectAll(State.connections)
    for boss, _ in pairs(State.animationStates) do Animation.cleanup(boss) end
end

function Farm.farmBoss(boss)
    local pData = Utils.getPlayerData()
    if not pData then return end
    local config = BOSS_CONFIGS[boss.Name]
    if not config then return end
    
    State.currentBoss = boss.Name
    State.healthThreshold = pData.humanoid.MaxHealth * 0.5
    
    Animation.setup(boss, config)
    Utils.notify("Farming " .. boss.Name, 3)
    
    local attackThread = Combat.startAttacking()
    Combat.enableNoclip()
    Teleport.toBoss(boss, config)
    
    local lastPlayerCheck = tick()
    while State.running and State.currentBoss == boss.Name do
        local cPData = Utils.getPlayerData()
        if not cPData or not Utils.isValidBoss(boss) then break end
        
        if cPData.humanoid.Health < State.healthThreshold then
            Farm.cleanup() Teleport.toSafeSpot(true) task.wait(3) break
        end
        
        if tick() - lastPlayerCheck >= 2 then
            lastPlayerCheck = tick()
            local nearby = Detection.isPlayerNearby(boss, BossFarm.Settings.PlayerDetectionRadius)
            if nearby then
                Farm.cleanup() Teleport.toSafeSpot(true) task.wait(2) break
            end
        end
        task.wait(BossFarm.Settings.HealthCheckInterval)
    end
    if attackThread then task.cancel(attackThread) end
    Animation.cleanup(boss)
end

BossFarm.start = Farm.start
BossFarm.stop = Farm.stop
BossFarm.bossDatabase = bossDatabase

return BossFarm