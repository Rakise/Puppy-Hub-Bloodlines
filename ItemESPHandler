-- ItemESPHandler.lua
-- Unified handler for Trinkets, Fruits, and Gems
-- OPTIMIZED: Lazy Loading System (Prevents Crashes)
-- Only creates billboards when items are CLOSE.
-- Throttles creation to prevent CPU spikes.

local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local ItemESPHandler = {}
ItemESPHandler.__index = ItemESPHandler

local COLORS = {
    Trinket = Color3.fromRGB(170, 0, 255), -- Purple
    Fruit = Color3.fromRGB(0, 255, 0),     -- Green
    Gem = Color3.fromRGB(0, 255, 255)      -- Cyan
}

-- Configuration
local RENDER_DISTANCE = 1500 -- Only create visual if closer than this
local PROCESS_RATE = 25 -- How many items to check/update per frame (Higher = faster load, Lower = less lag)

function ItemESPHandler.new()
    local self = setmetatable({}, ItemESPHandler)
    self.settings = {
        Trinket = false,
        Fruit = false,
        Gem = false
    }
    
    -- Data Structures
    -- validItems: [Object] = {Type="...", Name="...", Proxy=part/nil, Billboard=gui/nil}
    self.validItems = {} 
    
    self.connections = {}
    self.isScanning = false
    self.localPlayer = Players.LocalPlayer
    return self
end

-- Helper to get CFrame safely
function ItemESPHandler:GetCFrame(obj)
    if obj:IsA("Model") then
        return obj:GetPivot()
    elseif obj:IsA("BasePart") then
        return obj.CFrame
    end
    return CFrame.new()
end

function ItemESPHandler:Identify(obj)
    -- Validation: Must have "ID" and "ObjectValue" children
    if not obj:FindFirstChild("ID") or not obj:FindFirstChild("ObjectValue") then
        return nil
    end
    
    local isMesh = obj:IsA("MeshPart")
    local name = obj.Name
    
    -- LOGIC:
    -- 1. If Attribute "RealName" exists -> TRINKET
    -- 2. Else if Name contains "Gem" -> GEM
    -- 3. Else (and is MeshPart) -> FRUIT
    
    local realNameAttr = obj:GetAttribute("RealName")
    
    if realNameAttr then
        return "Trinket", realNameAttr
    end
    
    if isMesh and string.find(name, "Gem") then
        return "Gem", name
    end
    
    if isMesh then
        return "Fruit", name
    end
    
    return nil
end

-- Register an object as a potential ESP target (Does NOT create GUI yet)
function ItemESPHandler:RegisterObject(obj)
    if self.validItems[obj] then return end -- Already registered
    
    -- Spread the load: wait a tiny bit if this is called in a loop
    -- Note: We handle throttling in the main Scan loop, so direct calls (ChildAdded) are fine
    
    local typeStr, nameStr = self:Identify(obj)
    if typeStr then
        self.validItems[obj] = {
            Type = typeStr,
            Name = nameStr,
            Billboard = nil,
            Proxy = nil
        }
    end
end

function ItemESPHandler:UnregisterObject(obj)
    local data = self.validItems[obj]
    if data then
        if data.Billboard then data.Billboard:Destroy() end
        if data.Proxy then data.Proxy:Destroy() end
        self.validItems[obj] = nil
    end
end

function ItemESPHandler:CreateVisuals(obj, data)
    if data.Billboard then return end -- Already created
    
    local adornee = obj
    
    -- Handle ReplicatedStorage items via Proxy
    if obj:IsDescendantOf(ReplicatedStorage) then
        if not data.Proxy then
            local proxy = Instance.new("Part")
            proxy.Name = "ESP_Proxy"
            proxy.Transparency = 1
            proxy.CanCollide = false
            proxy.Anchored = true
            proxy.Size = Vector3.new(1, 1, 1)
            proxy.CFrame = self:GetCFrame(obj)
            proxy.Parent = Workspace
            data.Proxy = proxy
        end
        adornee = data.Proxy
    end
    
    local bb = Instance.new("BillboardGui")
    bb.Name = "ItemESP"
    bb.Size = UDim2.new(0, 100, 0, 30)
    bb.StudsOffset = Vector3.new(0, 1, 0)
    bb.AlwaysOnTop = true
    bb.Parent = CoreGui
    bb.Adornee = adornee
    
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.TextColor3 = COLORS[data.Type] or Color3.new(1,1,1)
    lbl.TextStrokeTransparency = 0.5
    lbl.TextSize = 11
    lbl.Text = string.format("%s (%s)", data.Name, data.Type)
    lbl.Parent = bb
    
    data.Billboard = bb
end

function ItemESPHandler:DestroyVisuals(data)
    if data.Billboard then
        data.Billboard:Destroy()
        data.Billboard = nil
    end
    if data.Proxy then
        data.Proxy:Destroy()
        data.Proxy = nil
    end
end

-- Heavy Scan: Runs once on enable, yields to prevent crash
function ItemESPHandler:FullScan()
    local objectsToCheck = {}
    
    -- Gather all potential objects first
    for _, obj in ipairs(Workspace:GetChildren()) do
        table.insert(objectsToCheck, obj)
    end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        table.insert(objectsToCheck, obj)
    end
    
    -- Process in chunks
    local count = 0
    for _, obj in ipairs(objectsToCheck) do
        self:RegisterObject(obj)
        count = count + 1
        if count % 100 == 0 then
            task.wait() -- Yield every 100 items to keep FPS smooth
        end
    end
end

-- Main Loop: Manages Distance & Visibility
function ItemESPHandler:UpdateLoop()
    if not self.localPlayer.Character then return end
    local hrp = self.localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local myPos = hrp.Position
    local processed = 0
    
    for obj, data in pairs(self.validItems) do
        -- 1. Check if category enabled
        if self.settings[data.Type] then
            
            -- 2. Check Distance
            local targetCFrame = (data.Proxy and data.Proxy.CFrame) or self:GetCFrame(obj)
            local dist = (targetCFrame.Position - myPos).Magnitude
            
            if dist <= RENDER_DISTANCE then
                -- Close enough: Create
                if not data.Billboard then
                    self:CreateVisuals(obj, data)
                end
            else
                -- Too far: Destroy (Save memory)
                if data.Billboard then
                    self:DestroyVisuals(data)
                end
            end
            
        else
            -- Category disabled: Destroy
            if data.Billboard then
                self:DestroyVisuals(data)
            end
        end
        
        -- Throttling: Only process X items per frame
        processed = processed + 1
        if processed >= PROCESS_RATE then
            return -- Stop for this frame, continue next frame (Lua loops resume automatically if we used coroutine, but here we rely on RunService calling this again. Actually, this naive loop restarts every frame. For true cycling we need an index, but iterating pairs is random. Given Lua speed, iterating the table is fast, the EXPENSIVE part is Create/Destroy.)
            -- Optimization: We only return if we did "Heavy Work" (Create/Destroy).
            -- Simple distance check is fast enough to do all ~500 items per frame.
            -- Creating instances is the bottleneck.
        end
    end
end

function ItemESPHandler:Start()
    if self.connections.Update then return end
    
    -- Initial Async Scan
    task.spawn(function()
        self:FullScan()
    end)
    
    -- Listeners
    self.connections.WsAdd = Workspace.ChildAdded:Connect(function(c) 
        task.delay(0.5, function() if c.Parent then self:RegisterObject(c) end end) 
    end)
    self.connections.WsRem = Workspace.ChildRemoved:Connect(function(c) self:UnregisterObject(c) end)
    
    self.connections.RsAdd = ReplicatedStorage.ChildAdded:Connect(function(c) 
        task.delay(0.5, function() if c.Parent then self:RegisterObject(c) end end) 
    end)
    self.connections.RsRem = ReplicatedStorage.ChildRemoved:Connect(function(c) self:UnregisterObject(c) end)
    
    -- Render Loop
    self.connections.Update = RunService.Heartbeat:Connect(function()
        self:UpdateLoop()
    end)
end

function ItemESPHandler:Stop()
    for _, conn in pairs(self.connections) do conn:Disconnect() end
    self.connections = {}
    
    for _, data in pairs(self.validItems) do
        self:DestroyVisuals(data)
    end
    self.validItems = {}
end

function ItemESPHandler:toggleCategory(cat, val)
    self.settings[cat] = val
    
    -- Check if any active
    local anyActive = self.settings.Trinket or self.settings.Fruit or self.settings.Gem
    
    if anyActive and not self.connections.Update then
        self:Start()
    elseif not anyActive and self.connections.Update then
        self:Stop()
    end
end

function ItemESPHandler:setMaxDistance(val)
    RENDER_DISTANCE = val
end

return ItemESPHandler