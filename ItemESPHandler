-- ItemESPHandler.lua
-- Unified handler for Trinkets, Fruits, and Gems
-- OPTIMIZED: Uses GetChildren + ChildAdded
-- FIXED: Fruit detection logic (No Attribute = Fruit)
-- NEW: Support for ReplicatedStorage items via Proxy Parts

local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ItemESPHandler = {}
ItemESPHandler.__index = ItemESPHandler

local COLORS = {
    Trinket = Color3.fromRGB(170, 0, 255), -- Purple
    Fruit = Color3.fromRGB(0, 255, 0),     -- Green
    Gem = Color3.fromRGB(0, 255, 255)      -- Cyan
}

function ItemESPHandler.new()
    local self = setmetatable({}, ItemESPHandler)
    self.settings = {
        Trinket = false,
        Fruit = false,
        Gem = false
    }
    self.billboards = {} -- [Part] = {gui, type, proxyPart}
    self.maxDistance = 1000
    self.connections = {}
    return self
end

-- Determine Type based on STRICT user rules
function ItemESPHandler:Identify(obj)
    -- Validation: Must have "ID" and "ObjectValue" children
    if not obj:FindFirstChild("ID") or not obj:FindFirstChild("ObjectValue") then
        return nil
    end
    
    local isMesh = obj:IsA("MeshPart")
    local name = obj.Name
    
    -- LOGIC:
    -- 1. If Attribute "RealName" exists -> TRINKET
    -- 2. Else if Name contains "Gem" -> GEM
    -- 3. Else (and is MeshPart) -> FRUIT
    
    local realNameAttr = obj:GetAttribute("RealName")
    
    if realNameAttr then
        -- It has RealName, so it IS a Trinket
        return "Trinket", realNameAttr
    end
    
    -- No RealName attribute below this point
    
    if isMesh and string.find(name, "Gem") then
        return "Gem", name
    end
    
    if isMesh then
        -- No attribute, not a gem, must be a fruit
        return "Fruit", name
    end
    
    return nil -- Unknown
end

-- Helper to get CFrame safely
function ItemESPHandler:GetCFrame(obj)
    if obj:IsA("Model") then
        return obj:GetPivot()
    elseif obj:IsA("BasePart") then
        return obj.CFrame
    end
    return CFrame.new()
end

function ItemESPHandler:CreateBillboard(part, typeStr, nameStr)
    if self.billboards[part] then return end
    
    local adornee = part
    local proxyPart = nil
    
    -- If in ReplicatedStorage, create a fake part in Workspace for the billboard to stick to
    if part:IsDescendantOf(ReplicatedStorage) then
        proxyPart = Instance.new("Part")
        proxyPart.Name = "ESP_Proxy"
        proxyPart.Transparency = 1
        proxyPart.CanCollide = false
        proxyPart.Anchored = true
        proxyPart.Size = Vector3.new(1, 1, 1)
        proxyPart.CFrame = self:GetCFrame(part)
        proxyPart.Parent = Workspace
        
        adornee = proxyPart
    end
    
    local bb = Instance.new("BillboardGui")
    bb.Name = "ItemESP"
    bb.Size = UDim2.new(0, 100, 0, 30)
    bb.StudsOffset = Vector3.new(0, 1, 0)
    bb.AlwaysOnTop = true
    bb.Parent = CoreGui
    bb.Adornee = adornee
    
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.TextColor3 = COLORS[typeStr] or Color3.new(1,1,1)
    lbl.TextStrokeTransparency = 0.5
    lbl.TextSize = 11
    lbl.Text = string.format("%s (%s)", nameStr, typeStr)
    lbl.Parent = bb
    
    self.billboards[part] = {
        gui = bb, 
        type = typeStr, 
        proxyPart = proxyPart -- Store reference to destroy later
    }
end

function ItemESPHandler:CheckObject(obj)
    if not self.billboards[obj] and (obj:IsA("MeshPart") or obj:IsA("Model")) then
        local typeStr, nameStr = self:Identify(obj)
        if typeStr then
            self:CreateBillboard(obj, typeStr, nameStr)
        end
    end
end

function ItemESPHandler:RemoveBillboard(obj)
    local data = self.billboards[obj]
    if data then
        if data.gui then data.gui:Destroy() end
        if data.proxyPart then data.proxyPart:Destroy() end
        self.billboards[obj] = nil
    end
end

function ItemESPHandler:Scan()
    -- Scan Workspace
    for _, obj in ipairs(Workspace:GetChildren()) do
        self:CheckObject(obj)
    end
    -- Scan ReplicatedStorage
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        self:CheckObject(obj)
    end
end

function ItemESPHandler:Update()
    local camPos = Workspace.CurrentCamera.CFrame.Position
    
    for part, data in pairs(self.billboards) do
        if not part.Parent then
            self:RemoveBillboard(part)
        else
            local isEnabled = self.settings[data.type]
            
            if isEnabled then
                -- Use proxy position if available, otherwise part position
                local targetCFrame = data.proxyPart and data.proxyPart.CFrame or self:GetCFrame(part)
                local dist = (targetCFrame.Position - camPos).Magnitude
                
                if dist > self.maxDistance then
                    isEnabled = false
                end
            end
            
            data.gui.Enabled = isEnabled
        end
    end
end

function ItemESPHandler:StartLoop()
    if self.connections.Update then return end
    
    self:Scan()
    
    -- Workspace Listener
    self.connections.WsChildAdded = Workspace.ChildAdded:Connect(function(child)
        task.delay(0.5, function() if child.Parent then self:CheckObject(child) end end)
    end)
    self.connections.WsChildRemoved = Workspace.ChildRemoved:Connect(function(child)
        self:RemoveBillboard(child)
    end)
    
    -- ReplicatedStorage Listener
    self.connections.RsChildAdded = ReplicatedStorage.ChildAdded:Connect(function(child)
        task.delay(0.5, function() if child.Parent then self:CheckObject(child) end end)
    end)
    self.connections.RsChildRemoved = ReplicatedStorage.ChildRemoved:Connect(function(child)
        self:RemoveBillboard(child)
    end)
    
    self.connections.Update = RunService.Heartbeat:Connect(function()
        self:Update()
    end)
end

function ItemESPHandler:StopLoop()
    if self.connections.WsChildAdded then self.connections.WsChildAdded:Disconnect() end
    if self.connections.WsChildRemoved then self.connections.WsChildRemoved:Disconnect() end
    if self.connections.RsChildAdded then self.connections.RsChildAdded:Disconnect() end
    if self.connections.RsChildRemoved then self.connections.RsChildRemoved:Disconnect() end
    if self.connections.Update then self.connections.Update:Disconnect() end
    
    self.connections = {}
    
    for part, _ in pairs(self.billboards) do
        self:RemoveBillboard(part)
    end
end

function ItemESPHandler:toggleCategory(cat, val)
    self.settings[cat] = val
    if self.settings.Trinket or self.settings.Fruit or self.settings.Gem then
        self:StartLoop()
    else
        self:StopLoop()
    end
end

function ItemESPHandler:setMaxDistance(val)
    self.maxDistance = val
end

return ItemESPHandler