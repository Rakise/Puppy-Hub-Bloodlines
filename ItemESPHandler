-- ItemESPHandler.lua
-- Unified handler for Trinkets, Fruits, and Gems
-- FIX: Pending/Retry system to catch items that load their properties late
-- FIX: Proper cleanup on disable

local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local ItemESPHandler = {}
ItemESPHandler.__index = ItemESPHandler

local COLORS = {
    Trinket = Color3.fromRGB(170, 0, 255), -- Purple
    Fruit = Color3.fromRGB(0, 255, 0),     -- Green
    Gem = Color3.fromRGB(0, 255, 255)      -- Cyan
}

-- Configuration
local RENDER_DISTANCE = 1500 
local PROCESS_RATE = 25 

function ItemESPHandler.new()
    local self = setmetatable({}, ItemESPHandler)
    self.settings = {
        Trinket = false,
        Fruit = false,
        Gem = false
    }
    
    -- Lists
    self.validItems = {}   -- [Obj] = {Type, Name, Billboard, Proxy}
    self.pendingItems = {} -- [Obj] = timestamp (Waiting for ID/ObjectValue to load)
    
    self.connections = {}
    self.localPlayer = Players.LocalPlayer
    return self
end

function ItemESPHandler:GetCFrame(obj)
    if obj:IsA("Model") then return obj:GetPivot()
    elseif obj:IsA("BasePart") then return obj.CFrame end
    return CFrame.new()
end

function ItemESPHandler:Identify(obj)
    -- Strict Validation: Must have ID and ObjectValue
    if not obj:FindFirstChild("ID") or not obj:FindFirstChild("ObjectValue") then
        return nil
    end
    
    local isMesh = obj:IsA("MeshPart")
    local name = obj.Name
    
    local realNameAttr = obj:GetAttribute("RealName")
    if realNameAttr then return "Trinket", realNameAttr end
    
    if isMesh and string.find(name, "Gem") then return "Gem", name end
    if isMesh then return "Fruit", name end
    
    return nil
end

-- Called when a child is added (Workspace or ReplicatedStorage)
function ItemESPHandler:OnItemAdded(obj)
    if self.validItems[obj] or self.pendingItems[obj] then return end
    
    -- Filter: Only care about Models or MeshParts
    if obj:IsA("Model") or obj:IsA("MeshPart") then
        -- Add to pending to check later (gives time for children to replicate)
        self.pendingItems[obj] = tick()
    end
end

function ItemESPHandler:OnItemRemoved(obj)
    self.pendingItems[obj] = nil
    
    local data = self.validItems[obj]
    if data then
        self:DestroyVisuals(data)
        self.validItems[obj] = nil
    end
end

function ItemESPHandler:CreateVisuals(obj, data)
    if data.Billboard then return end
    
    local adornee = obj
    
    -- ReplicatedStorage Proxy Logic
    if obj:IsDescendantOf(ReplicatedStorage) then
        if not data.Proxy then
            local proxy = Instance.new("Part")
            proxy.Name = "ESP_Proxy"
            proxy.Transparency = 1
            proxy.CanCollide = false
            proxy.Anchored = true
            proxy.Size = Vector3.new(1, 1, 1)
            proxy.CFrame = self:GetCFrame(obj)
            proxy.Parent = Workspace
            data.Proxy = proxy
        end
        adornee = data.Proxy
    end
    
    local bb = Instance.new("BillboardGui")
    bb.Name = "ItemESP"
    bb.Size = UDim2.new(0, 100, 0, 30)
    bb.StudsOffset = Vector3.new(0, 1, 0)
    bb.AlwaysOnTop = true
    bb.Parent = CoreGui
    bb.Adornee = adornee
    
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.TextColor3 = COLORS[data.Type] or Color3.new(1,1,1)
    lbl.TextStrokeTransparency = 0.5
    lbl.TextSize = 11
    lbl.Text = string.format("%s (%s)", data.Name, data.Type)
    lbl.Parent = bb
    
    data.Billboard = bb
end

function ItemESPHandler:DestroyVisuals(data)
    if data.Billboard then data.Billboard:Destroy() data.Billboard = nil end
    if data.Proxy then data.Proxy:Destroy() data.Proxy = nil end
end

-- Slow Loop: Checks pending items to see if they have loaded enough to be identified
function ItemESPHandler:ValidationLoop()
    for obj, startTime in pairs(self.pendingItems) do
        if not obj.Parent then
            self.pendingItems[obj] = nil
        else
            local typeStr, nameStr = self:Identify(obj)
            if typeStr then
                -- Success! It's a valid item now
                self.validItems[obj] = {
                    Type = typeStr,
                    Name = nameStr,
                    Billboard = nil,
                    Proxy = nil
                }
                self.pendingItems[obj] = nil -- Remove from pending
            elseif tick() - startTime > 10 then
                -- Timeout after 10 seconds of failing to identify (probably not an item)
                self.pendingItems[obj] = nil 
            end
        end
    end
end

-- Fast Loop: Handles visuals based on distance/settings
function ItemESPHandler:RenderLoop()
    if not self.localPlayer.Character then return end
    local hrp = self.localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local myPos = hrp.Position
    local processed = 0
    
    for obj, data in pairs(self.validItems) do
        -- Ensure object still exists
        if not obj.Parent then
            self:OnItemRemoved(obj)
        else
            -- Logic
            if self.settings[data.Type] then
                local targetCFrame = (data.Proxy and data.Proxy.CFrame) or self:GetCFrame(obj)
                local dist = (targetCFrame.Position - myPos).Magnitude
                
                if dist <= RENDER_DISTANCE then
                    if not data.Billboard then self:CreateVisuals(obj, data) end
                else
                    if data.Billboard then self:DestroyVisuals(data) end
                end
            else
                if data.Billboard then self:DestroyVisuals(data) end
            end
        end
        
        processed = processed + 1
        if processed > PROCESS_RATE then break end -- Throttle updates per frame
    end
end

function ItemESPHandler:Start()
    if self.connections.Render then return end
    
    -- Initial Scan
    for _, v in ipairs(Workspace:GetChildren()) do self:OnItemAdded(v) end
    for _, v in ipairs(ReplicatedStorage:GetChildren()) do self:OnItemAdded(v) end
    
    -- Listeners
    self.connections.WsAdd = Workspace.ChildAdded:Connect(function(c) self:OnItemAdded(c) end)
    self.connections.WsRem = Workspace.ChildRemoved:Connect(function(c) self:OnItemRemoved(c) end)
    self.connections.RsAdd = ReplicatedStorage.ChildAdded:Connect(function(c) self:OnItemAdded(c) end)
    self.connections.RsRem = ReplicatedStorage.ChildRemoved:Connect(function(c) self:OnItemRemoved(c) end)
    
    -- Loops
    self.connections.Render = RunService.Heartbeat:Connect(function() self:RenderLoop() end)
    
    -- Run validation every 0.5s (2Hz)
    self.connections.Validation = RunService.Heartbeat:Connect(function()
        if tick() % 0.5 < 0.1 then
            self:ValidationLoop()
        end
    end)
end

function ItemESPHandler:Stop()
    for _, c in pairs(self.connections) do c:Disconnect() end
    self.connections = {}
    
    -- Clean Visuals
    for _, data in pairs(self.validItems) do
        self:DestroyVisuals(data)
    end
    
    -- Clean Lists
    self.validItems = {}
    self.pendingItems = {}
end

function ItemESPHandler:toggleCategory(cat, val)
    self.settings[cat] = val
    
    local anyActive = self.settings.Trinket or self.settings.Fruit or self.settings.Gem
    
    if anyActive and not self.connections.Render then
        self:Start()
    elseif not anyActive and self.connections.Render then
        self:Stop()
    end
end

function ItemESPHandler:setMaxDistance(val)
    RENDER_DISTANCE = val
end

return ItemESPHandler